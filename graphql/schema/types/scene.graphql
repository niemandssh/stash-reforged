type ScenePerformer {
  performer: Performer!
  small_role: Boolean!
  role_description: String
}

type SceneFileType {
  size: String
  duration: Float
  video_codec: String
  audio_codec: String
  width: Int
  height: Int
  framerate: Float
  bitrate: Int
}

type ScenePathsType {
  screenshot: String # Resolver
  preview: String # Resolver
  stream: String # Resolver
  webp: String # Resolver
  vtt: String # Resolver
  sprite: String # Resolver
  funscript: String # Resolver
  interactive_heatmap: String # Resolver
  caption: String # Resolver
}

type SceneMovie {
  movie: Movie!
  scene_index: Int
}

type SceneGroup {
  group: Group!
  scene_index: Int
}

type VideoCaption {
  language_code: String!
  caption_type: String!
}

type VideoFilters {
  contrast: Int
  brightness: Int
  gamma: Int
  saturate: Int
  hue_rotate: Int
  white_balance: Int
  red: Int
  green: Int
  blue: Int
  blur: Int
}

type VideoTransforms {
  rotate: Int
  scale: Int
  aspect_ratio: Int
}

input VideoFiltersInput {
  contrast: Int
  brightness: Int
  gamma: Int
  saturate: Int
  hue_rotate: Int
  white_balance: Int
  red: Int
  green: Int
  blue: Int
  blur: Int
}

input VideoTransformsInput {
  rotate: Int
  scale: Int
  aspect_ratio: Int
}

type Scene {
  id: ID!
  title: String
  code: String
  details: String
  director: String
  url: String @deprecated(reason: "Use urls")
  urls: [String!]!
  date: String # Release date
  shoot_date: String # Filming/shooting date
  # rating expressed as 1-100
  rating100: Int
  organized: Boolean!
  pinned: Boolean!
  o_counter: Int
  omgCounter: Int
  interactive: Boolean!
  interactive_speed: Int
  captions: [VideoCaption!]
  is_broken: Boolean!
  is_not_broken: Boolean!
  audio_offset_ms: Int!
  audio_playback_speed: Float!
  force_hls: Boolean!
  disable_next_scene_overlay: Boolean!
  is_probably_broken: Boolean! # Resolver
  created_at: Time!
  updated_at: Time!
  "The last time play count was updated"
  last_played_at: Time
  "The time index a scene was left at"
  resume_time: Float
  "The total time a scene has spent playing"
  play_duration: Float
  "The number ot times a scene has been played"
  play_count: Int

  "Video trimming - start time in seconds"
  start_time: Float
  "Video trimming - end time in seconds"
  end_time: Float

  "Video filters applied to the scene"
  video_filters: VideoFilters
  "Video transformations applied to the scene"
  video_transforms: VideoTransforms

  "Times a scene was played"
  play_history: [Time!]!
  "Times the o counter was incremented"
  o_history: [Time!]!
  "Times the omg counter was incremented"
  omg_history: [Time!]!

  files: [VideoFile!]!
  paths: ScenePathsType! # Resolver
  scene_markers: [SceneMarker!]!
  galleries: [Gallery!]!
  studio: Studio
  groups: [SceneGroup!]!
  movies: [SceneMovie!]! @deprecated(reason: "Use groups")
  tags: [Tag!]!
  performer_tag_ids: [PerformerTag!]!
  performers: [Performer!]! @deprecated(reason: "Use scene_performers")
  scene_performers: [ScenePerformer!]!
  stash_ids: [StashID!]!

  "Return valid stream paths"
  sceneStreams: [SceneStreamEndpoint!]!

  "Similar scenes based on performers, groups, tags, and studio"
  similar_scenes(limit: Int): [SimilarScene!]!
}

type SimilarScene {
  scene: Scene!
  similarity_score: Float!
  similarity_score_data: SimilarityScoreData
}

type SimilarityScoreData {
  enhanced_tags: Float
  normal_tags: Float
  reduced_tags: Float
  tags: Float
  performers: Float
  groups: Float
  studio: Float
  penalty: Float
}

input SceneMovieInput {
  movie_id: ID!
  scene_index: Int
}

input PerformerTagInput {
  performer_id: ID
  tag_ids: [ID!]!
}

type PerformerTag {
  performer_id: ID
  tag_ids: [ID!]!
}

input SceneGroupInput {
  group_id: ID!
  scene_index: Int
}

input ScenePerformerInput {
  performer_id: ID!
  small_role: Boolean!
  role_description: String
}

input SceneCreateInput {
  title: String
  code: String
  details: String
  director: String
  url: String @deprecated(reason: "Use urls")
  urls: [String!]
  date: String
  shoot_date: String
  # rating expressed as 1-100
  rating100: Int
  organized: Boolean
  is_broken: Boolean
  studio_id: ID
  gallery_ids: [ID!]
  performer_ids: [ID!] @deprecated(reason: "Use scene_performers")
  scene_performers: [ScenePerformerInput!]
  groups: [SceneGroupInput!]
  movies: [SceneMovieInput!] @deprecated(reason: "Use groups")
  tag_ids: [ID!]
  "This should be a URL or a base64 encoded data URL"
  cover_image: String
  stash_ids: [StashIDInput!]

  """
  The first id will be assigned as primary.
  Files will be reassigned from existing scenes if applicable.
  Files must not already be primary for another scene.
  """
  file_ids: [ID!]
}

input SceneUpdateInput {
  clientMutationId: String
  id: ID!
  title: String
  code: String
  details: String
  director: String
  url: String @deprecated(reason: "Use urls")
  urls: [String!]
  date: String
  shoot_date: String
  # rating expressed as 1-100
  rating100: Int
  o_counter: Int
    @deprecated(reason: "Unsupported - Use sceneIncrementO/sceneDecrementO")
  organized: Boolean
  pinned: Boolean
  is_broken: Boolean
  is_not_broken: Boolean
  audio_offset_ms: Int
  audio_playback_speed: Float
  force_hls: Boolean
  disable_next_scene_overlay: Boolean
  studio_id: ID
  gallery_ids: [ID!]
  performer_ids: [ID!] @deprecated(reason: "Use scene_performers")
  scene_performers: [ScenePerformerInput!]
  groups: [SceneGroupInput!]
  movies: [SceneMovieInput!] @deprecated(reason: "Use groups")
  tag_ids: [ID!]
  performer_tag_ids: [PerformerTagInput!]
  "This should be a URL or a base64 encoded data URL"
  cover_image: String
  stash_ids: [StashIDInput!]

  "The time index a scene was left at"
  resume_time: Float
  "The total time a scene has spent playing"
  play_duration: Float
  "The number ot times a scene has been played"
  play_count: Int
    @deprecated(
      reason: "Unsupported - Use sceneIncrementPlayCount/sceneDecrementPlayCount"
    )

  "Video trimming - start time in seconds"
  start_time: Float
  "Video trimming - end time in seconds"
  end_time: Float

  "Video filters applied to the scene"
  video_filters: VideoFiltersInput
  "Video transformations applied to the scene"
  video_transforms: VideoTransformsInput

  primary_file_id: ID
}

enum BulkUpdateIdMode {
  SET
  ADD
  REMOVE
}

input BulkUpdateIds {
  ids: [ID!]
  mode: BulkUpdateIdMode!
}

input BulkSceneUpdateInput {
  clientMutationId: String
  ids: [ID!]
  title: String
  code: String
  details: String
  director: String
  url: String @deprecated(reason: "Use urls")
  urls: BulkUpdateStrings
  date: String
  shoot_date: String
  # rating expressed as 1-100
  rating100: Int
  organized: Boolean
  is_broken: Boolean
  is_not_broken: Boolean
  studio_id: ID
  gallery_ids: BulkUpdateIds
  performer_ids: BulkUpdateIds
  tag_ids: BulkUpdateIds
  group_ids: BulkUpdateIds
  movie_ids: BulkUpdateIds @deprecated(reason: "Use group_ids")
}

input SceneDestroyInput {
  id: ID!
  delete_file: Boolean
  delete_generated: Boolean
}

input ScenesDestroyInput {
  ids: [ID!]!
  delete_file: Boolean
  delete_generated: Boolean
}

type FindScenesResultType {
  count: Int!
  "Total duration in seconds"
  duration: Float!
  "Total file size in bytes"
  filesize: Float!
  scenes: [Scene!]!
}

input SceneParserInput {
  ignoreWords: [String!]
  whitespaceCharacters: String
  capitalizeTitle: Boolean
  ignoreOrganized: Boolean
}

type SceneMovieID {
  movie_id: ID!
  scene_index: String
}

type SceneParserResult {
  scene: Scene!
  title: String
  code: String
  details: String
  director: String
  url: String
  date: String
  shoot_date: String
  # rating expressed as 1-5
  rating: Int @deprecated(reason: "Use 1-100 range with rating100")
  # rating expressed as 1-100
  rating100: Int
  studio_id: ID
  gallery_ids: [ID!]
  performer_ids: [ID!]
  movies: [SceneMovieID!]
  tag_ids: [ID!]
}

type SceneParserResultType {
  count: Int!
  results: [SceneParserResult!]!
}

input SceneHashInput {
  checksum: String
  oshash: String
}

type SceneStreamEndpoint {
  url: String!
  mime_type: String
  label: String
}

input AssignSceneFileInput {
  scene_id: ID!
  file_id: ID!
}

input SceneMergeInput {
  """
  If destination scene has no files, then the primary file of the
  first source scene will be assigned as primary
  """
  source: [ID!]!
  destination: ID!
  # values defined here will override values in the destination
  values: SceneUpdateInput

  # if true, the source history will be combined with the destination
  play_history: Boolean
  o_history: Boolean
}

type HistoryMutationResult {
  count: Int!
  history: [Time!]!
}

input ReduceResolutionInput {
  scene_id: ID!
  file_id: ID!
  target_width: Int!
  target_height: Int!
}

input TrimVideoInput {
  scene_id: ID!
  file_id: ID!
  start_time: Float!
  end_time: Float!
}

input SceneSaveFilteredScreenshotInput {
  id: ID!
  image: String!
  at: Float
}
